use crate::error::Result;
use bitflags::bitflags;
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use std::io::Cursor;

bitflags! {
    /// Method access flags.
    ///
    /// See: <https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-4.html#jvms-4.5:~:text=method_info%20structure%20are%20as%20follows%3A-,access_flags,-The%20value%20of%20the%20access_flags>
    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
    pub struct MethodAccessFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const PUBLIC = 0x0001;
        /// Declared private; accessible only within the defining class and other classes belonging to the same nest (ยง5.4.4).
        const PRIVATE = 0x0002;
        /// Declared protected; may be accessed within subclasses.
        const PROTECTED = 0x0004;
        /// Declared static.
        const STATIC = 0x0008;
        /// Declared final; must not be overridden (ยง5.4.5).
        const FINAL = 0x0010;
        /// Declared synchronized; invocation is wrapped by a monitor use.
        const SYNCHRONIZED = 0x0020;
        /// A bridge method, generated by the compiler.
        const BRIDGE = 0x0040;
        /// Declared with variable number of arguments.
        const VARARGS = 0x0080;
        /// Declared native; implemented in a language other than the Java programming language.
        const NATIVE = 0x0100;
        /// Declared abstract; no implementation is provided.
        const ABSTRACT = 0x0400;
        /// In a class file whose major version number is at least 46 and at most 60: Declared strictfp.
        const STRICT = 0x0800;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
    }
}

impl Default for MethodAccessFlags {
    fn default() -> MethodAccessFlags {
        MethodAccessFlags::empty()
    }
}

impl MethodAccessFlags {
    /// Deserialize the `MethodAccessFlags` from bytes.
    ///
    /// # Errors
    /// Should not occur; reserved for future use.
    pub fn from_bytes(bytes: &mut Cursor<Vec<u8>>) -> Result<MethodAccessFlags> {
        let access_flags = bytes.read_u16::<BigEndian>()?;
        let method_access_flags = MethodAccessFlags::from_bits_truncate(access_flags);
        Ok(method_access_flags)
    }

    /// Serialize the `MethodAccessFlags` to bytes.
    ///
    /// # Errors
    /// Should not occur; reserved for future use.
    pub fn to_bytes(&self, bytes: &mut Vec<u8>) -> Result<()> {
        bytes.write_u16::<BigEndian>(self.bits())?;
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_default() {
        assert_eq!(MethodAccessFlags::empty(), MethodAccessFlags::default());
    }

    #[test]
    fn test_all_access_flags() {
        let access_flags: u16 = u16::MAX;
        let mut bytes = Cursor::new(access_flags.to_be_bytes().to_vec());
        assert_eq!(
            Ok(MethodAccessFlags::PUBLIC
                | MethodAccessFlags::PRIVATE
                | MethodAccessFlags::PROTECTED
                | MethodAccessFlags::STATIC
                | MethodAccessFlags::FINAL
                | MethodAccessFlags::SYNCHRONIZED
                | MethodAccessFlags::BRIDGE
                | MethodAccessFlags::VARARGS
                | MethodAccessFlags::NATIVE
                | MethodAccessFlags::ABSTRACT
                | MethodAccessFlags::STRICT
                | MethodAccessFlags::SYNTHETIC),
            MethodAccessFlags::from_bytes(&mut bytes)
        );
    }

    #[test]
    fn test_access_flags() -> Result<()> {
        let access_flags = MethodAccessFlags::PUBLIC | MethodAccessFlags::FINAL;
        let mut bytes = Vec::new();
        access_flags.to_bytes(&mut bytes)?;
        let mut bytes = Cursor::new(bytes);
        assert_eq!(Ok(access_flags), MethodAccessFlags::from_bytes(&mut bytes));
        Ok(())
    }
}
